#include "utils.h"
//#include <unistd.h>
#include <getopt.h>
#include <climits>

bool processInputParams(int argc,  char* const argv[], Params& outParams, const char* optstring) {

    static struct option long_options[] =
    {
		{"host_name",            required_argument, NULL, 'i'},
        {"port",                 required_argument, NULL, 'p'},
        {"credentials_location", required_argument, NULL, 'l'},
        {"client_id",            required_argument, NULL, 'd'},
        {"measure_id",           required_argument, NULL, 's'},
        {"Num_of_parties",       required_argument, NULL, 'm'},
		{"process_name",         required_argument, NULL, 'n'},
        {"aborts"      ,         required_argument, NULL, 'a'},
        {"compute"     ,         optional_argument, NULL, 'c'},
        {"controller_socket_address"  ,         optional_argument, NULL, 'o'},
        {"input_file"  ,         optional_argument, NULL, 'f'},
        {"no-argument options",  no_argument,       NULL, 'W'},
        {"help",                 no_argument,       NULL, 'h'},
        {NULL, 0, NULL, 0}
    };

    char opt(0);
    std::cout << "cmdline arguments " << optstring <<std::endl;
    while ((opt = getopt_long(argc, argv, optstring, long_options, NULL)) != -1) {
        std::cerr << "opt1: " << opt << "; optarg: " << optarg << std::endl;
        switch (opt) {
        case 'i':
            outParams.host_name = optarg;
            break;
        case 'l':
            outParams.credentials_location = optarg;
            break;
        case 'd':
            outParams.client_id = optarg;
            break;
        case 's':
            outParams.measure_id = optarg;
            break;
        case 'm':
            outParams.Num_of_parties = optarg;
            break;
        case 'n':
            outParams.process_name = optarg;
            break;
        case 'a':
            outParams.aborts = optarg;
            break;
        case 'c':
            outParams.computation = optarg;
            break;
        case 'o':
            outParams.controller_socket_address = optarg;
            break;
        case 'f':
            outParams.input_file = optarg;
            break;
        case 'p':
            outParams.port = optarg;
            break;
        case 'W':
            if (std::string(optarg) == "ssloff")
                outParams.disableSSLAuthentication = true;
            // other no-argument options
            else
                return false;
            break;
        case 'h':
        default:
            return false;
        }
    }

    if (!outParams.port.size()) {
        std::cerr << "error: port number is a required option" << std::endl;
        return false;
    }
    else {
        int port = atoi(outParams.port.c_str());
        if (port < 0 || port >(int)USHRT_MAX) {
            //std::cerr << "USHRT_MAX: " << USHRT_MAX << std::endl;
            //std::cerr << "(int)USHRT_MAX: " << (int)USHRT_MAX << std::endl;
            //std::cerr << "port < 0: " << (port < 0) << std::endl;
            //std::cerr << "port >(int)USHRT_MAX: " << (port > (int)USHRT_MAX) << std::endl;
            std::cerr << "error: port number [" << port << "] is invalid (must be 0-65535)" << std::endl;
            return false;
        }
    }

    
    if (!outParams.host_name.size())
        outParams.host_name = "0.0.0.0";
    //outParams.host_name = "localhost";

    if (!outParams.credentials_location.size())
        outParams.credentials_location = CERTS_AND_KEYS_DIR;

    outParams.socket_address = std::string(outParams.host_name) + ":" + outParams.port;
    std::cerr << "outParams.socket_address [" << outParams.socket_address << "]" << std::endl;

    // names of the files generated by create_certs.sh
    const std::string root_cert_file_name("ca.crt");
    const std::string client_private_key_file_name("client_" + outParams.process_name + ".key");
    const std::string client_cert_chain_file_name("client_" + outParams.process_name + ".crt");
    const std::string server_private_key_file_name("server_" + outParams.process_name + ".key");
    const std::string server_cert_chain_file_name("server_" + outParams.process_name + ".crt");

    outParams.root_cert_file = std::string(outParams.credentials_location) + "/" + root_cert_file_name;
    outParams.server_private_key_file = std::string(outParams.credentials_location) + "/" + outParams.process_name + "/" + server_private_key_file_name;
    outParams.server_cert_chain_file = std::string(outParams.credentials_location)  + "/" + outParams.process_name+ "/" + server_cert_chain_file_name;
    outParams.client_private_key_file = std::string(outParams.credentials_location) + "/" + outParams.process_name + "/" + client_private_key_file_name;
    outParams.client_cert_chain_file = std::string(outParams.credentials_location) + "/" + outParams.process_name + "/" + client_cert_chain_file_name;

    return true;
}

void usage(const char* task) {
    std::cerr << "Usage: " << task << " [OPTIONS]..." << std::endl;
    std::cerr << "        [OPTIONS]:" << std::endl
        << "        <-p port number on the server host>" << std::endl
        << "        [-i IP or hostname of the server; localhost is the default]" << std::endl
        << "        [-l location of the files with credentials; CERTS_AND_KEYS_DIR is the default] " << std::endl
        << "        [-d client ID (producer, broker or consumer) " << std::endl
        << "        [-n name of this process: server1, client2, consumer3, producer1, etc.] " << std::endl
        << "        [-W no-argument options: " << std::endl
        << "            -Wssloff - run task without SSL authentication] " << std::endl
        << "        -h prints this message" << std::endl;
}

std::string file2String(const std::string& filename) {
    std::ifstream t(filename);
    std::stringstream buffer;
    buffer << t.rdbuf();

    return buffer.str();
}

std::string buffer2PrintableString(const std::string& str) {
    std::stringstream buffer;
    for (char c : str) {
        if (static_cast<int>(c) > 31)
            buffer << c;
        else
            buffer << static_cast<int>(c);
    }
    return buffer.str();
}

std::string buffer2PrintableString(const char* str, size_t len) {
    std::stringstream buffer;
    for (size_t i = 0; i < len; ++i) {
        if (static_cast<int>(str[i]) > 31)
            buffer << str[i];
        else
            buffer << static_cast<int>(str[i]);
    }
    return buffer.str();
}
