/***
 * ï¿½ 2021 Duality Technologies, Inc. All rights reserved.
 * This is a proprietary software product of Duality Technologies, Inc.
 *protected under copyright laws and international copyright treaties, patent
 *law, trade secret law and other intellectual property rights of general
 *applicability. Any use of this software is strictly prohibited absent a
 *written agreement executed by Duality Technologies, Inc., which provides
 *certain limited rights to use this software. You may not copy, distribute,
 *make publicly available, publicly perform, disassemble, de-compile or reverse
 *engineer any part of this software, breach its security, or circumvent,
 *manipulate, impair or disrupt its operation.
 ***/
//#include "../src/peer_to_peer_framework/include/node.h"
#include "node.h"

int main(int argc, char** argv) {

    //OPENFHE_DEBUG_FLAG(debug_flag_val);  // set to true to turn on DEBUG() statements
	
	CommParams params;
	//char optstring[] = "i:p:l:n:W:h";
	if (!processInputParams(argc, argv, params)) {
		usage(argv[0]);
		exit(EXIT_FAILURE);
	}

	std::string node_name = params.NodeName;
	NodeImpl mynode;
   
	message_format Msgsent;
    Msgsent.NodeName = params.NodeName;

	mynode.Register(params); //initiate and add nodes
    mynode.Start();
	

	std::cout << "My name " << node_name << std::endl;

    
    //cryptocontext generation.
    //For now, the cryptocontext is generated by node 1 and sent to node 2. This will be changed later to be
    //generated by a key server when a client-server communication is added to the peer to peer framework.
	lbcrypto::CryptoContext<lbcrypto::DCRTPoly> cc(nullptr);

	int plaintextModulus = 65537;
	double sigma = 3.2;
	lbcrypto::SecurityLevel securityLevel = lbcrypto::SecurityLevel::HEStd_128_classic;
	usint batchSize = 1024;
	usint multDepth = 4;

    lbcrypto::CCParams<lbcrypto::CryptoContextBFVRNS> parameters;		

	parameters.SetPlaintextModulus(plaintextModulus);
	parameters.SetSecurityLevel(securityLevel);
	parameters.SetStandardDeviation(sigma);
	parameters.SetSecretKeyDist(lbcrypto::UNIFORM_TERNARY);
	parameters.SetMultiplicativeDepth(multDepth);
	parameters.SetBatchSize(batchSize);

	cc = GenCryptoContext(parameters);

	cc->Enable(lbcrypto::PKE);
	cc->Enable(lbcrypto::LEVELEDSHE);
	cc->Enable(lbcrypto::MULTIPARTY);

   	std::string nodeA = "Node1"; 
    std::string nodeB = "Node2";//todo: how to pass number of nodes


	mynode.sendSerialMsg(cc, Msgsent, "cryptocontext", nodeA);
    mynode.sendSerialMsg(cc, Msgsent, "cryptocontext", nodeB);

	//std::cout << "ring dimension from cryptocontext = "
    //        << cc->GetCryptoParameters()
    //                   ->GetElementParams()
    //                   ->GetCyclotomicOrder() /2
    //        << std::endl;

	std::vector<std::string> node_names = mynode.getConnectedNodes();

    std::cout << "Finished sending cryptocontext" << std::endl;

    lbcrypto::PublicKey<lbcrypto::DCRTPoly> FinalPubKey(nullptr);
	mynode.getSerialMsgWait(FinalPubKey, "PublicKey", nodeB);
   
	//get the final evaluation mult key if client id is not 1
	lbcrypto::EvalKey<lbcrypto::DCRTPoly> evalMultFinal(nullptr);
	mynode.getSerialMsgWait(evalMultFinal, "evalmixmultkey", nodeA);
	cc->InsertEvalMultKey({evalMultFinal});

    //get ciphertext from clients and randomize
    //generate a random vector r to mask the ciphertext received
    lbcrypto::Plaintext plainrandom_r;
        
    std::vector<int64_t> random_rvec;
	random_rvec.reserve(12);//ringsize);
	for (size_t i = 0; i < 12; i++) {//ringsize; i++) { //generate a random array of shorts
	    random_rvec.emplace_back(std::rand() % plaintextModulus);
	}

	//pack them into a packed plaintext (vector encryption)
	plainrandom_r = cc->MakePackedPlaintext(random_rvec);
	
    auto encryptedrandom_r = cc->Encrypt(FinalPubKey, plainrandom_r); // Encrypt

    lbcrypto::Ciphertext<lbcrypto::DCRTPoly> ctA (nullptr), ctB (nullptr), maskedCText (nullptr);

	std::cout << "Receiving ciphertext from nodes" << std::endl;
    //get ciphertext from nodeA
    mynode.getSerialMsgWait(ctA, "ciphertext", nodeA);
    maskedCText = cc->EvalMult(encryptedrandom_r, ctA);

    //send randomized ciphertext
    mynode.sendSerialMsg(maskedCText, Msgsent, "randomized ciphertext", nodeA);
    
    //get ciphertext from nodeA
    mynode.getSerialMsgWait(ctB, "ciphertext", nodeB);
    maskedCText = cc->EvalMult(encryptedrandom_r, ctB);
    //send randomized ciphertext
    mynode.sendSerialMsg(maskedCText, Msgsent, "randomized ciphertext", nodeB);
    
	//********************************************************************    
    //print the key sizes and ciphertext cizes
	#if 0
	if (TEST_MODE) {
	    std::cout << "Final Public key received size: " << serializedFinalPubKey.size() << std::endl;
		std::cout << "EvalMult key size size: " << evmmKey.str().size() << std::endl;	
        std::cout << "Ciphertext sent size: " << osCT.str().size() << std::endl;
        std::cout << "Partial Ciphertext sent size: " << osPartialCT.str().size() << std::endl;
	}
	#endif
    //*******************************************************************************



	mynode.Stop(); //exception thrown if not stopped


	return 0;
}
