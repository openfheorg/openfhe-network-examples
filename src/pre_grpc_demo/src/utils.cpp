
#include <getopt.h>
#include <climits>

#include "utils.h"

bool processInputParams(int argc,  char* const argv[], Params& outParams, const char* optstring) {

    static struct option long_options[] =
    {
        {"key_server_socket_address",                 required_argument, NULL, 'k'},
        {"upstream_broker_socket_address",            required_argument, NULL, 'u'},
        {"broker_socket_address",                     required_argument, NULL, 'd'},
        {"upstream_broker_name",                      required_argument, NULL, 'i'},
        {"upstream_key_server_socket_address",        required_argument, NULL, 's'},
        {"channel_name",                              required_argument, NULL, 'c'},
        {"credentials_location",                      required_argument, NULL, 'l'},
        {"security_model",                            optional_argument, NULL, 'm'},
        {"process_name",                              required_argument, NULL, 'n'},
        {"access_map_path",                           required_argument, NULL, 'a'},
        {"no-argument options",                       no_argument,       NULL, 'W'},
        {"help",                                      no_argument,       NULL, 'h'},
        {NULL, 0, NULL, 0}
    };

    char opt(0);
    std::cout << "cmdline arguments " << optstring <<std::endl;
    while ((opt = getopt_long(argc, argv, optstring, long_options, NULL)) != -1) {
        std::cerr << "opt1: " << opt << "; optarg: " << optarg << std::endl;
        switch (opt) {
        case 'k':
            outParams.key_server_socket_address = optarg;
            break;
        case 'u':
            outParams.upstream_broker_socket_address = optarg;
            break;
        case 'd':
            outParams.broker_socket_address = optarg;
            break;
        case 'i':
            outParams.upstream_broker_name = optarg;
            break;
        case 's':
            outParams.upstream_key_server_socket_address = optarg;
            break;
        case 'c':
            outParams.channel_name = optarg;
            break;
        case 'l':
            outParams.credentials_location = optarg;
            break;
        case 'm':
            outParams.security_model = optarg;
            break;
        case 'n':
            outParams.process_name = optarg;
            break;
        case 'a':
            outParams.access_map_path = optarg;
            break;
        case 'W':
            if (std::string(optarg) == "ssloff")
                outParams.disableSSLAuthentication = true;
            // other no-argument options
            else
                return false;
            break;
        case 'h':
        default:
            return false;
        }
    }
	if (outParams.security_model == "" ) {
	  std::cerr << "error: security model is required option" << std::endl;
	  return false;
    }

    if (!outParams.key_server_socket_address.size()) {
        std::cerr << "error: port number is a required option" << std::endl;
        return false;
    }

    if (!outParams.key_server_socket_address.size())
        outParams.key_server_socket_address = "0.0.0.0:00";
    //outParams.host_name = "localhost";

    if (!outParams.credentials_location.size())
        outParams.credentials_location = CERTS_AND_KEYS_DIR;

    // names of the files generated by create_certs.sh
    const std::string root_cert_file_name("ca.crt");
    const std::string client_private_key_file_name("client_" + outParams.process_name + ".key");
    const std::string client_cert_chain_file_name("client_" + outParams.process_name + ".crt");
    const std::string server_private_key_file_name("server_" + outParams.process_name + ".key");
    const std::string server_cert_chain_file_name("server_" + outParams.process_name + ".crt");

    outParams.root_cert_file = std::string(outParams.credentials_location) + "/" + outParams.process_name + "/" + root_cert_file_name;
    outParams.server_private_key_file = std::string(outParams.credentials_location) + "/" + outParams.process_name + "/" + server_private_key_file_name;
    outParams.server_cert_chain_file = std::string(outParams.credentials_location) + "/" + outParams.process_name + "/" + server_cert_chain_file_name;
    outParams.client_private_key_file = std::string(outParams.credentials_location) + "/" + outParams.process_name + "/" + client_private_key_file_name;
    outParams.client_cert_chain_file = std::string(outParams.credentials_location) + "/" + outParams.process_name + "/" + client_cert_chain_file_name;

    return true;
}

void usage(const char* task) {
    std::cerr << "Usage: " << task << " [OPTIONS]..." << std::endl;
    //"k:u:d:i:s:c:l:m:n:W:h"
    std::cerr << "        [OPTIONS]:" << std::endl
        << "        <-k socket address of key server, example - localhost:50050" << std::endl
        << "        [-u socket address of the upstream broker, example - localhost:50051]" << std::endl
        << "        [-d socket address of this process" << std::endl
        << "        [-i name of the upstream broker" << std::endl
        << "        [-s socket address of upstream key server " << std::endl
        << "        [-c channel requested by a consumer in the format producerName-consumerName " << std::endl
        << "        [-l location of the files with credentials; CERTS_AND_KEYS_DIR is the default] " << std::endl
        << "        [-m Security model (INDCPA, FIXED_NOISE_HRA, NOISE_FLOODING_HRA, NOISE_FLOODING_HRA_HYBRID) " << std::endl
        << "        [-n name of this process: server1, client2, consumer3, producer1, etc.] " << std::endl
        << "        [-a access map path for the key server] " << std::endl
        << "        [-W no-argument options: " << std::endl
        << "            -Wssloff - run task without SSL authentication] " << std::endl
        << "        -h prints this message" << std::endl
        << "        Refer to README for examples" << std::endl;
}

std::string file2String(const std::string& filename) {
    std::ifstream t(filename);
    std::stringstream buffer;
    buffer << t.rdbuf();

    return buffer.str();
}

std::string buffer2PrintableString(const std::string& str) {
    std::stringstream buffer;
    for (char c : str) {
        if (static_cast<int>(c) > 31)
            buffer << c;
        else
            buffer << static_cast<int>(c);
    }
    return buffer.str();
}

std::string buffer2PrintableString(const char* str, size_t len) {
    std::stringstream buffer;
    for (size_t i = 0; i < len; ++i) {
        if (static_cast<int>(str[i]) > 31)
            buffer << str[i];
        else
            buffer << static_cast<int>(str[i]);
    }
    return buffer.str();
}

std::vector<std::string> SplitString(std::string data, std::string delimiter) {

    std::vector<std::string> v;

    size_t pos = 0;
    std::string token;
    while ((pos = data.find(delimiter)) != std::string::npos) {
        token = data.substr(0, pos);
        v.emplace_back(token);
        data.erase(0, pos + delimiter.length());
    }
    v.push_back(data);
    return v;
}

std::map<std::string,std::vector<std::string>> ParseRoutingTable(std::string routingtablepath, std::string broker_name, std::string destination_client_name) {

    std::map<std::string, std::vector<std::string>> channel;
    auto routingTableFile = routingtablepath + broker_name;
    std::string data;

    std::ifstream routingTable (routingTableFile);

    if (!routingTable) {
        std::cout << "Unable to open routing table file";
        exit(EXIT_FAILURE);  // terminate with error
    }

    if(routingTable.peek() != std::ifstream::traits_type::eof()) {
        while ((routingTable >> data))
        {
            auto channelNameSplit = SplitString(data, ":");
            std::string channelName = channelNameSplit[0];

            auto channelSourceSplit = SplitString(channelNameSplit[1], ">");
            std::string channelSource = channelSourceSplit[0];

            auto channelDestSplit = SplitString(channelSourceSplit[1], ";");
            std::string channelDest = channelDestSplit[0];

            std::string channelFlag = channelDestSplit[1];

            if(channelDest == destination_client_name) {
                channel[channelName] = {channelSource, channelDest, channelFlag};
            }
        }
    }
    return channel;
}

void UpdateRoutingTable(std::string routingtablepath, std::string channel_name, std::string broker_name, std::string upstream_client_name, std::string downstream_client_name, bool source_sink_flag) {
    auto routingTableFile = routingtablepath + broker_name;
    std::string data;
    std::string source_sink = "";

    std::ofstream routingTable(routingTableFile, std::ios::app);

    if (!routingTable) {
        std::cout << "Unable to open routing table file";
        exit(EXIT_FAILURE);  // terminate with error
    }

    if(source_sink_flag)
        source_sink = "source";

    data = channel_name + ":" + upstream_client_name + ">" + downstream_client_name + ";" + source_sink;

    routingTable << data << std::endl;
    routingTable.close();
}

void ClearRoutingTable(std::string routingtablefile) {
    std::ofstream routingTable(routingtablefile, std::ios::trunc);
    routingTable.close();
}

std::vector<std::string> ParseAccessMap(std::string accessmappath) {

    std::string data;
    std::vector<std::string> accessMap;

    std::ifstream accessMapFile (accessmappath);

    if (!accessMapFile) {
        std::cout << "Unable to open access map file";
        exit(EXIT_FAILURE);  // terminate with error
    }

    while ((accessMapFile >> data))
    {
        accessMap.push_back(data);
    }
    return accessMap;
}

//function to read in a string containing a hexadecimal digits, returns a vector of
// bits (little endian, least sigingicant bit in index 0,  stored in integers.
// note a modulus p is also required, but at this time only p=2 is supported.
//

std::vector<int64_t> hexstr2intvec(std::string instr, unsigned int p){

  if (p !=2) {
	std::cerr << "only p = 2 is supported";
	exit (-1);
  }
  //std::cout << "Input string `" << instr <<"'" <<std::endl;

  unsigned int len = instr.size();

  //read hex string two digits at a time (one byte) from the least significant digit

  std::vector<unsigned char> raw_bytes = {};

  for (int ix = len-2; ix >= 0; ix -=2){
    unsigned int i;
    std::string s = instr.substr(ix, 2);
    std::istringstream iss(s);
    //std::cout << s << " = ";

    iss >> std::hex >> i;

    //std::cout << i << " ";
    raw_bytes.push_back((unsigned char) i);
  }

  std::cout << std::endl;

  std::vector<int64_t> out = {};
  //now convert the byte to integers mod p
  for (size_t ix = 0; ix < raw_bytes.size(); ix++) {
	auto tmp = (int)raw_bytes[ix];
	for (int j = 0 ; j < 8; j++) {
	  out.push_back(tmp%2);
	  tmp /=2;
	}
  }
  return out;
}


//function to read in a vector of
// bits (little endian, least sigingicant bit in index 0,  stored in integers.
// and output a hex string.
// note a modulus p is also required, but at this time only p=2 is supported.
//

std::string intvec2hexstr(const std::vector<int64_t> in_bits, unsigned int p){

  if (p !=2) {
	std::cerr << "only p = 2 is supported";
	exit (-1);
  }

  std::vector<unsigned char> out_bytes = {};
  //now convert the bits to bytes
  int kx =0;
  for (size_t ix = 0; ix < in_bits.size(); ix+=8) {
	out_bytes.push_back((unsigned char) 0);
	unsigned char tmp(0);
	for (int jx = 0 ; jx < 8; jx++) {
	  tmp |= in_bits[ix+jx] << jx;
	}
	out_bytes[kx] = tmp;
	kx++;
  }

  unsigned int len = out_bytes.size();

  //write hex string two digits at a time (one byte) from the least significant digit
  std::string s;
  std::ostringstream oss(s);

  for (int ix = len-1; ix >= 0; ix-- ){
	//std::cout << std::hex << (unsigned int) out_bytes[ix];
	oss << std::setw(2) << std::hex << std::setfill('0') << (unsigned int)out_bytes[ix];

  }
  //std::cout << std::endl;
  oss << std::flush;
  std::string outstr(oss.str());

  //std::cout << "Output string `" << outstr <<"'" <<std::endl;

  return outstr;

 }
