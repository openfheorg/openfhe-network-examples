#include "node_utils.h"
#include <getopt.h>
#include <climits>

bool processInputParams(int argc,  char* const argv[], CommParams& outParams, const char* optstring) {

    static struct option long_options[] =
    {
		{"NodeName",             required_argument, NULL, 'n'},
        {"socket_address",       required_argument, NULL, 's'},
        {"NetworkMapFile",       required_argument, NULL, 'm'},
        {"ApplicationFile",      required_argument, NULL, 'f'},
        {"ExtraArgumentString",  required_argument, NULL, 'e'},
        {"credentials_location", required_argument, NULL, 'l'},
        {"no-argument options",  no_argument,       NULL, 'W'},
        {"help",                 no_argument,       NULL, 'h'},
        {NULL, 0, NULL, 0}
    };
	
    char opt(0);
    if (TEST_MODE){
	  std::cout << "cmdline arguments " << optstring <<std::endl;
	}
    while ((opt = getopt_long(argc, argv, optstring, long_options, NULL)) != -1) {
	  if (TEST_MODE){
		std::cout << "opt1: " << opt << "; optarg: " << optarg << std::endl;
	  }
	  switch (opt) {
	  case 'n':
		outParams.NodeName = optarg;
		break;
	  case 's':
		outParams.socket_address = optarg;
		break;
	  case 'm':
		outParams.NetworkMapFile = optarg;
		break;
	  case 'f':
		outParams.ApplicationFile = optarg;
		break;
	  case 'e':
		outParams.ExtraArgument = optarg;
		break;
	  case 'l':
		outParams.credentials_location = optarg;
		break;
	  case 'W':
		if (std::string(optarg) == "ssloff")
		  outParams.disableSSLAuthentication = true;
		// other no-argument options
		else
		  return false;
		break;
	  case 'h':
	  default:
		return false;
	  }
    }
	
    if (!outParams.socket_address.size()) {
        std::cerr << "error: port number is a required option" << std::endl;
        return false;
    }
    
    if (!outParams.socket_address.size())
        outParams.socket_address = "0.0.0.0:00";
    //outParams.host_name = "localhost";

    if (!outParams.credentials_location.size())
        outParams.credentials_location = CERTS_AND_KEYS_DIR;

    // names of the files generated by create_certs.sh
    const std::string root_cert_file_name("ca.crt");
    const std::string client_private_key_file_name("client_" + outParams.NodeName + ".key");
    const std::string client_cert_chain_file_name("client_" + outParams.NodeName + ".crt");
    const std::string server_private_key_file_name("server_" + outParams.NodeName + ".key");
    const std::string server_cert_chain_file_name("server_" + outParams.NodeName + ".crt");

    outParams.root_cert_file = std::string(outParams.credentials_location) + "/" + outParams.NodeName + "/" + root_cert_file_name;
    outParams.server_private_key_file = std::string(outParams.credentials_location) + "/" + outParams.NodeName + "/" + server_private_key_file_name;
    outParams.server_cert_chain_file = std::string(outParams.credentials_location) + "/" + outParams.NodeName + "/"  + server_cert_chain_file_name;
    outParams.client_private_key_file = std::string(outParams.credentials_location) + "/"  + outParams.NodeName + "/" + client_private_key_file_name;
    outParams.client_cert_chain_file = std::string(outParams.credentials_location) + "/"  + outParams.NodeName + "/" + client_cert_chain_file_name;

    return true;
}

void usage(const char* task) {
    std::cerr << "Usage: " << task << " [OPTIONS]..." << std::endl;
    std::cerr << "        [OPTIONS]:" << std::endl
        << "        [-n name of the node ]" << std::endl
        << "        [-s IP or hostname of the node server; localhost is the default with the port number]" << std::endl
        << "        [-m location of the network map file " << std::endl
        << "        [-f location of the application data file " << std::endl
        << "        [-e location of the application arguments " << std::endl
        << "        [-l location of the files with credentials; CERTS_AND_KEYS_DIR is the default] " << std::endl
        << "        [-W no-argument options: " << std::endl
        << "            -Wssloff - run task without SSL authentication] " << std::endl
        << "        -h prints this message" << std::endl;
}

std::string file2String(const std::string& filename) {
    std::ifstream t(filename);
    std::stringstream buffer;
    buffer << t.rdbuf();

    return buffer.str();
}

std::string buffer2PrintableString(const std::string& str) {
    std::stringstream buffer;
    for (char c : str) {
        if (static_cast<int>(c) > 31)
            buffer << c;
        else
            buffer << static_cast<int>(c);
    }
    return buffer.str();
}

std::string buffer2PrintableString(const char* str, size_t len) {
    std::stringstream buffer;
    for (size_t i = 0; i < len; ++i) {
        if (static_cast<int>(str[i]) > 31)
            buffer << str[i];
        else
            buffer << static_cast<int>(str[i]);
    }
    return buffer.str();
}

std::vector<std::string> SplitString(std::string& data, std::string delimiter) {
    std::vector<std::string> v;

    size_t pos = 0;
    std::string token;
    while ((pos = data.find(delimiter)) != std::string::npos) {
        token = data.substr(0, pos);
        v.emplace_back(token);
        data.erase(0, pos + delimiter.length());
    }
    v.push_back(data);
    return v;
}
